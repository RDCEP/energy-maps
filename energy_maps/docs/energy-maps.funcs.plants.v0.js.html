<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: energy-maps.funcs.plants.v0.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: energy-maps.funcs.plants.v0.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * @file Provides draw functions and any helpers for all power plants.
 * @author Benjamin Kleeman
 * @author Nathan Matteson
 */

/**
 * @typedef {Object} geojson_geometry
 * @property {String} type
 * @property {Array} coordinates
 */

/**
 * @typedef {Object} power_plant_properties
 * @property {String} total_cap - Annual capacity in TKTK
 * @property {String} primary_fu - Primary fuel
 */

/**
 * @typedef {Object} power_plant_feature
 * @property {geojson_geometry} geometry
 * @property {power_plant_properties} properties
 */

/**
 * @typedef {Object} power_plant_geojson
 * @property {Object} crs
 * @property {power_plant_feature[]} features
 */

/**
 * @typedef {power_plant_geojson} power_plant
 * @property
 */

/**
 *
 * @param {power_plant_geojson[]} queued_data
 */

const draw_single_plant = function draw_single_plant(ctx, queued_data, fuel) {
  console.log('draw_single_plant');

  let wells = queued_data[0];

  // Filter out all records based on primary fuel and draw their white layer
  features = wells.features
    .filter(function(d) {
      return d.properties.primary_fu === fuel; 
    });
  features.forEach(function(d) {
    let xy = projection(d.geometry.coordinates);
    draw_power_plant(ctx, xy, viz.white, +d.properties.total_cap);
  });
  // Draw the standard layer
  features.forEach(function(d, i) {
    let xy = projection(d.geometry.coordinates);
    if (xy === null) {
      //
    } else {
      let color = 'black';
      switch(fuel) {
        case 'COAL': color = viz.plants.coal; break;
        case 'GEO': color = viz.plants.geo; break;
        case 'HYC': color = viz.plants.hydro; break;
        case 'NG': color = viz.plants.gas; break;
        case 'NUC': color = viz.plants.nuclear; break;
        case 'PET': color = viz.plants.oil; break;
        case 'SUN': color = viz.plants.solar; break;
        case 'WND': color = viz.plants.wind; break;
        default:
          color =  'rgba(255, 255, 255, 0)';  break;
      }
      draw_power_plant(ctx, xy, color, +d.properties.total_cap);
    }
    if (i === features.length - 1) { hide_spinner(); }
  });

};

const draw_power_plants = function draw_power_plants(ctx, queued_data, nff) {
  console.log('draw_power_plants');

  let wells = queued_data[0];

  // Toggle fuels for fossil vs non-fossil fuels
  let fuels = ['PET', 'NG', 'COAL'];
  if (nff) {
    fuels = ['SUN', 'WND', 'NUC', 'GEO', 'HYC'];
  }

  // Attempt at filtering by layer
  // If you decide to bring this back in and make it work, 
  // change method signature to draw_power_plants(ctx, queued_data, nff, set)

  // if (set === fuels[0]) {
  //   wells.features.filter(function(d) {
  //     return fuels.indexOf(d.properties.primary_fu) == fuels[0];
  //   })
  //   .forEach(function(d) {
  //     let xy = projection(d.geo.coordinates);
  //     draw_power_plant(ctx, xy, iz.whit, +d.properties.total_cap);
  //   });
  //   wells.features
  //     .filter(function(d) {
  //       return fuels.indexOf(d.properties.primary_fu) == fuels[0];
  //     }).forEach(function(d) {
  //       let xy = projection(d.geometry.coordinates);
  //       if (xy == null) {
  //         //
  //       } else {
  //         let color = viz.plants.oil;
  //         draw_power_plant(ctx, xy, color, +d.properties.total_cap);
  //       }
  //     })
  // }
  wells.features.filter(function(d) {
      return fuels.indexOf(d.properties.primary_fu) > -1;
    })
    .forEach(function(d) {
      let xy = projection(d.geometry.coordinates);
      draw_power_plant(ctx, xy, viz.white, +d.properties.total_cap);
    });
  wells.features
    .filter(function(d) {
      return fuels.indexOf(d.properties.primary_fu) > -1;
    }).forEach(function(d) {
      let xy = projection(d.geometry.coordinates);
      if (xy === null) {
        //
      } else {
        let color = 'black';
        switch(d.properties.primary_fu) {
          case 'COAL': color = viz.plants.coal; break;
          case 'NG': color = viz.plants.gas; break;
          case 'PET': color = viz.plants.oil; break;
          case 'HYC': color = viz.plants.hydro; break;
          case 'SUN': color = viz.plants.solar; break;
          case 'WND': color = viz.plants.wind; break;
          case 'GEO': color = viz.plants.geo; break;
          case 'NUC': color = viz.plants.nuclear; break;
          default:
            color =  'rgba(255, 255, 255, 0)';  break;
        }
        draw_power_plant(ctx, xy, color, +d.properties.total_cap);
      }
    });
  // plants_legend(ctx, nff);
};

const draw_ff_plants = function draw_ff_plants(ctx, queued_data) {
  draw_power_plants(ctx, queued_data, false)
};

const draw_nff_plants = function draw_nff_plants(ctx, queued_data) {
  draw_power_plants(ctx, queued_data, true)
};

// const draw_coal_plants = function draw_coal_plants(ctx, queued_data) {
//   draw_power_plants(ctx, queued_data, false)
// };

const draw_power_plant = function draw_power_plant(ctx, xy, color, r) {
  ctx.strokeStyle = viz.plants.stroke.light;
  ctx.lineWidth = viz.plants.stroke.width;
  ctx.fillStyle = color;
  r = Math.sqrt(r / Math.PI) * viz.plants.scale;
  ctx.beginPath();
  // Draw larger circle for stroke, so that stroke aligns to outside of
  //  of circumference
  draw_circle(ctx, xy, r + ctx.lineWidth);
  // FIXME: Need a better method of changing stroke color for lighter circles.
  if (color !== viz.white) {
    if (color === viz.plants.gas) {
      ctx.strokeStyle = 'darkblue';
    } else if (color === viz.plants.solar) {
      ctx.strokeStyle = 'darkorange';
      // ctx.strokeStyle = viz.plants.stroke.dark;
    }
    ctx.stroke();
  }
  draw_circle(ctx, xy, r);
  ctx.fill();
};

const draw_coal_plants = function draw_coal_plants(ctx, queued_data) {
  draw_single_plant(ctx, queued_data, 'COAL')
};

const draw_ng_plants = function draw_ng_plants(ctx, queued_data) {
  draw_single_plant(ctx, queued_data, 'NG')
};

const draw_petro_plants = function draw_petro_plants(ctx, queued_data) {
  draw_single_plant(ctx, queued_data, 'PET')
};

const draw_hydro_plants = function draw_hydro_plants(ctx, queued_data) {
  draw_single_plant(ctx, queued_data, 'HYC')
};

const draw_nuclear_plants = function draw_nuclear_plants(ctx, queued_data) {
  draw_single_plant(ctx, queued_data, 'NUC')
};

const draw_wind_farms = function draw_wind_farms(ctx, queued_data) {
  draw_single_plant(ctx, queued_data, 'WND')
};

const draw_solar_plants = function draw_solar_plants(ctx, queued_data) {
  draw_single_plant(ctx, queued_data, 'SUN')
};

const draw_geo_plants = function draw_geo_plants(ctx, queued_data) {
  draw_single_plant(ctx, queued_data, 'GEO')
};

</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Namespaces</h3><ul><li><a href="Init.html">Init</a></li></ul><h3>Global</h3><ul><li><a href="global.html#canvas_width">canvas_width</a></li><li><a href="global.html#classes">classes</a></li><li><a href="global.html#draw_box">draw_box</a></li><li><a href="global.html#draw_circle">draw_circle</a></li><li><a href="global.html#draw_coal_mines">draw_coal_mines</a></li><li><a href="global.html#draw_cross">draw_cross</a></li><li><a href="global.html#draw_gas_wells">draw_gas_wells</a></li><li><a href="global.html#draw_grid_class">draw_grid_class</a></li><li><a href="global.html#draw_grid_class_ac_100_300">draw_grid_class_ac_100_300</a></li><li><a href="global.html#draw_grid_class_ac_345_735">draw_grid_class_ac_345_735</a></li><li><a href="global.html#draw_grid_class_ac_unk_and_under_100">draw_grid_class_ac_unk_and_under_100</a></li><li><a href="global.html#draw_grid_class_dc">draw_grid_class_dc</a></li><li><a href="global.html#draw_land">draw_land</a></li><li><a href="global.html#draw_mine">draw_mine</a></li><li><a href="global.html#draw_oil_refinery">draw_oil_refinery</a></li><li><a href="global.html#draw_oil_wells">draw_oil_wells</a></li><li><a href="global.html#draw_polygon">draw_polygon</a></li><li><a href="global.html#draw_railroads">draw_railroads</a></li><li><a href="global.html#draw_single_plant">draw_single_plant</a></li><li><a href="global.html#draw_triangle">draw_triangle</a></li><li><a href="global.html#draw_triangle_down">draw_triangle_down</a></li><li><a href="global.html#draw_x">draw_x</a></li><li><a href="global.html#filter_features">filter_features</a></li><li><a href="global.html#get_path">get_path</a></li><li><a href="global.html#get_xy">get_xy</a></li><li><a href="global.html#height">height</a></li><li><a href="global.html#line_width_kludge">line_width_kludge</a></li><li><a href="global.html#padding">padding</a></li><li><a href="global.html#path">path</a></li><li><a href="global.html#projection">projection</a></li><li><a href="global.html#viz">viz</a></li><li><a href="global.html#width">width</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.3</a> on Thu Jan 09 2020 16:43:58 GMT-0600 (Central Standard Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
